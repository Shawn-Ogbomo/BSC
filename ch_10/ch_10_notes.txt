What is our job as a programmer regarding I/O?	-Our role as a programmer is to set up I/O streams to the appropriate data sources 	and destinations.	-We must also be able to read and write from/to those streams.What are the 3 different kinds of input and output.streams 	of many data items 	-usually from files 	-network connections	-recording devices	-display devicesinteractions with a user at a keyboard interaction with a user through a graphical interface	-outputting objects 	-receiving mouse clicks what does an ostream do?	-an ostream turns values of various types into character sequences 	-sends those characters somewhere (such as to a console, a file, the main memory or 	another computer)	what is a buffer? a buffer is a data structure that the ostream uses internally to store the data you give it while communicating with the operating system.What is an istream?	-an istream takes  character sequences and turns them into values of various types 	-gets those characters from somewhere such as a 		-console		-a file 		-the main memory		-another computerWhat is a file at the most basic level?	-a file at the most basic level is a sequence of bytes starting from 0 upward.	- has a specific format that determines what the bytes mean 	What must we do to read a file?	-we must know its name 	- open it for reading 	-read in the characters 	-close it (this is done implicitly)what must we do to write a file	-name it 	-open it for writing or create a new file of that name 	-write out our objects 	-close it (this is done implicitly)what is an ifstream?-an ifstream is an istream for reading data from a filewhat is an ofstream?- an ofstream is the file version of ostream. Ofstream sends output to a filewhat is an fstream?-an fstream does both input and output. Reading and writing.open files early before doing any serious computationwhen a file stream goes out of scope its associated file is closed.When a file is closed the associated buffer is flushed the characters from the buffer are written to the file.opening a file implicitly as part of the creation of an istream is ideal -rely on the scope of the istream to close the file.*use a function and pass in the name of the file and another parameter for what you want to pass into it.test your stream after opening it.what is the great advantage of a file?	-a great advantage of a file is that it can be read repeatedly during debugging until 	your program works correctly.all errors of if stream falls under the 4 cases below what are the 4 stream states?good()	 the operation succeeded eof()	we hit end of input 'end of file'fail()	something bad happened we were looking for a digit and got a character 'x' eg simple format errorbad() something serious happened such as a disk read errora stream that is bad is also fail.what does cin.clear() do ? -cin.clear() takes the stream out of fail state so that we can look at characters from it againIf you encounter bad() it is best to throw an exception istream can do this for you we can rarely recover from bad()don't try unless you really have to.ios_ base is part of an  iostream that holds constants such as 	-bad bit 	-exceptions such as failure	-other useful stuff	you refer to them using the :: operator scope resolution operator	review******1, When dealing with input and output, how is the variety of devices dealt with in most modern computers? 	- the variety of devices are handled using an I/O  library.		-the I/O library makes the I/O from different sources appear as similar as possible	-now we don't need to constantly update our program to work with different 	devices.2, What fundamentally does an istream do? - an istream takes a sequence of characters and converts them into various types.  3, What fundamentally does an ostream do?	-an  ostream takes a various types and converts them into a sequence of characters4, what fundamentally is a file?	-a file is a series of bytes starting from 0 onward5,  What is a file format?	-set of rules that determine what the bytes mean6, Name 4 different types of devices that can require I/O for a program	- Printer	-mp3 player	-washing machine	-atm machine7, Steps for reading a file	-we must know the files name	-open the file  	-read in the characters	-close the file8, Steps for writing to a file	-name it 	-open it for writing or create a new file of that name 	-write out our objects 	-close it (this is done implicitly)9,  Name and define the 4 stream states	-good() all operations succeeded 	-bad() something seriously bad happened such as a disk read error	-fail() formatting error eg. we expected an integer and got a character	-eof() end of input end of fileDiscuss how the following input problems can be resolved10 ,  a.	 The user typing an out of range value  	 - handle the error in the code doing the read 	 - throw an exception 	-get int  and get int range         b.	 Getting no value (end of file)	 -        throw an exception and terminate the program	 - 	nobody presses ctrl+z by accident	c. The user typing something of the wrong type	    -once the stream fails()	    - call clear()	   - we can check if the character is a terminating character		-if It is then that is ok we can exit 		- if it is not then we can explicitly state the stream to failbit after ungetting() 		   the character 				- we can call clear() to set the stream to good and discard all the wrong types		 then unget the put the correct type in the stream and return.		11,  In what way is input usually harder than output?	- If the file is in an abstruse format, we would need to get the file in an acceptable 	format by making creating another file with the updated format and read from the 	file again. This is a difficult process since files can contain characters that are not ascii 	standard, or it could be in another language.	12,  In what way is output usually harder than input?	- out put may be more difficulty for programs where output devices have more of a 	chance of being unavailable , filled, or broken 	- we would need to test when outputting13,   Why do we want to separate input and output from computation?	-Input and output must be separated from computation since we need somewhere 	to write our results14. What are the most two common uses of the istream member function clear	-If the stream has failed we can use the clear member function of istream to return 	the state to a good state  from fail()  Then we can handle the error	(read the characters again)		- clear() member function can also be used to set the fail bit 		-eg the stream failed we used clear() once to see what the next character was			if it is not a terminating character we set the stream state back to fail.15. Usual function definitions for << and >> for a user defined type X are 	std::ostream& operator << (std::ostream& os, const X& x)	std::istream& operator >> (std::istream&is, X& x)terms*****bad(): stream state something really bad happened such as a disc read errorbuffer: is a data structure that is integral to an ostream or istream 	the data is stored in the buffer the buffer. The buffer  communicates with the os clear(): takes the stream out of fail state so that we can look at characters from it againclose(): function to close the file. Used by programmers who come from another tool device driver: deep within the operating system responsible for the detailed handling of I/Oeof() end of input (end of file)fail(): Stream state occurs when there is a format error 	we got an character instead of an integer when reading file: sequence of bytes starting from 0 upward.       has a specific format that determines what the bytes meangood(): Stream state all operations succeededifstream: takes a sequence characters and converts them into various types input device: where input comes from 	-keyboard	-file	-deviceinput operator >> : permits the user-defined type to work with input streamiostream: pipeline between main memory and disc		istream takes a stream of bytes from the disk and composes objects from 			them. Ostream converts objects in main memory into streams of bytes and 		writes them to diskofstream: permits writing of data to a file 		converts data of various types to a sequence of characters output device: 	can be a file 		  	-printer			-terminal			-screen			-other programsoutput operator << : permits our type to produce outputstream state: value of the stream object		-good()		-eof()		-fail()		-bad()structured file: we must be able to format files that are in an obscure  format		  -often we will get a file in such format; can create a format conversion 			    program to get the file in our desired formatterminator: terminating character to check for when the stream fails 		if we find it we can exit if not we must report an error.		a terminating character can also be used to stop reading from a file.unget(): puts character back into the stream.if stream goes bad() make it throw with this syntax- ist.exceptions(ist.exceptions() | ios_base::badbit )see pg 1090 for map function 