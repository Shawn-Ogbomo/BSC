Roman_int expression(Token_stream &ts){
Roman_int left{} = term  //call term
while(true){
// get next token  to fulfil  expression rule 
   switch(token){
	case '+'
		left += term
	case '-'
		left -= term 
	default 
	//put token back into stream 
	// exit  	
  }
 }
}


// Need Token class to store 
"+"
"-"
"/"
"*"
"^"
"sqrt"
"("
")"
"roman_int"

//Token_stream can hold
//a roman int 
//a character
//putback 
//get 
//clean_up_mess

//std::is_alpha() with iteration 
to get characters from cin and stop before operator is encountered eg "+'
try to build a roman int from the sequence of characters before the operator 
then proceed as usual.
use switch case...



oken Token_stream::get() {
	if (full) {
		full = false;
		return buffer;
	}
	char c{};
	std::cin >> c;
	switch (c) {
	case '+':
	case '-':
	case '*':
	case '$':
	case '/':
	case '%':
	case '(':
	case ')':
		return Token(c);
	default: 
	


	if its in the alphabet
	 -put it back into the stream and try to build a roman int...
	call operator >> for Roman_int type
	if its not throw an error stating that this calulator is for roman ints only 
	
	}
}






void calculate(Token_stream& ts) {
	while (true)try {
		std::cout << prompt << " ";
		Token t = ts.get();
		std::cout << expression(ts);
	}
	catch (const std::exception& e) {
		std::cerr << e.what() << "\n";
		clean_up_mess(ts);
	}
}





		main
		Token_stream ts{ std::cin };			//get token 
		Token t = ts.get();
		while (t.kind == print) {			//ignore prints 
			t = ts.get();
		}
		if t.kind is a quit token or exit
			-exit the program...

		calculate(ts);


if (isalpha(c) && std::cin.peek() != '\n' and the character is not a roman numeral) {
			std::string s;
			//put the character back into the input stream...
			while( c is an alphabet)
				s+= c;
			put the next character back into the input stream...
			if s is equal to "exit"
				return a quit token....
		}


void Util::end_of_loop(std::istream& ist, char term, std::string& message) {
	if (ist.fail()) {
		ist.clear();
			char ch{};
			while (ist >> ch ) {
				if ch is a term return
				else set the stream to failbit and return  
			}
	}
}

char roman_letter(char c) { //checks if the target character is a roman letter.		

	create a vector of chars to hold valid roman numerals 
	evaluate target character against each index in the vector 
	if target character is in the vector 
		- true

	else 
	return a false
}

Roman_int::Roman_int(const char letter)   //test
	: roman_character{ letter },
	value{},
	roman_code{} {
	if (islower(roman_character)) {
		roman_character = toupper(roman_character);
	}
	


}

std::string integer_to_roman_code(int val) {		//parse string from int

	if 1000 can fit into val evenly 
		- assign the amount of times 1000 can go into val
	  	to thousands 
	 	-then minus 1000* multiplier from value 
		assign M to string up to amount of times 1000 can go into the target 		int


	-if 100 can fit into val evenly
	  -assign the amount of times 100 can go into val to hundreds 
	  -then minus 100* multiplier from value 
		assign C to string up to amount of times 100 can go into the target 			int

	if 10 can fit into val evenly 
		-assign the amount oftimes 10 can go into val to tens 
		then minus 10* multiplier from value 
	assign X to string up to amount of times 10 can go into the target 			int

	if 5 can go in 
	....


	 - assign the amount of times 1 can go into val to ones 	
	 -then minus 1* multiplier from value 
	assign I up to amount of times 1 can go into target int 
	//store the value in Place_value object

	
	if thousands 
	- store 'M' to the amount of thousands in string 

INVARIANT can handle  > 3M

problems with C 
ok till 300
400 CD
500 D
600 DC
700 DCC
800 DCCC
900 CM

Problems with X 
ok till 30 
40 XL
50 L 
60 LX
70 LXX
80 LXXX
90 XC

}

Problems with I
{
  ok till 3 III
  4 IV
  5 V 
  6 VI 
  7 VII
  8 VIII
 9  IX 
}
thousands  2 
hundreds    1 
tens 	  7
ones     2

std::string integer_to_roman_code(int& val) {
	constexpr int max_value = 3999;
	if (val > max_value || val < 0) {
		throw std::invalid_argument{ "cannot represent " + std::to_string(val) + " as a roman numeral..." };
	}
	Place_value p;
	std::string roman_notation;
	int result{};
	constexpr int repeat_limit = 3;
	std::vector<Token_gen::Token> toks = { {"IV",4}, {'V',5},{"IX",9},{"XL",40},{"L",50},{"XC",90},{"CM",900} };
	if (result = val / Place_value::Multiplier::thousand) {
		p.thousands = result;
		for (int i{}; i < p.thousands; ++i) {
			roman_notation += 'M';
		}
		val -= (p.thousands * Place_value::Multiplier::thousand);
	}
	if (result = val / Place_value::Multiplier::hundred) {
		p.hundreds = result;
		if (p.hundreds > repeat_limit) {
			//create token for c,100
			//cd
			//cm
			//d
			// represent 400-900 as a string
		}
	}
	for (int i{}; i < p.hundreds; ++i) {
		roman_notation += 'C';
	}
	val -= (p.hundreds * Place_value::Multiplier::hundred);
	if (result = val / Place_value::Multiplier::ten) {
		p.tens = result;
		for (int i{}; i < p.tens; ++i) {
			roman_notation += 'X';
		}
		val -= (p.tens * Place_value::Multiplier::ten);
	}
	if (val) {
		p.ones = val;
		for (int i{}; i < p.ones; ++i) {
			roman_notation += 'I';
		}
	}
	return roman_notation;
}